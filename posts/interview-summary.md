---
title: '「中文」2023 找实习面试纠正小总结'
date: '2023-05-03'
---

## 总览
这两个月里面前前后后面试了差不多十几次，总结起来的是：**八股都是很常规的，只需要背在牛客上各位大佬所总结的那些八股就好，不需要全背，背高频考点即可。但仍有一些细枝末节没答好，以及「自我介绍」「项目介绍」上还需要重新整理一下。**

## 没准备好的八股

以下是没有准备好的八股需要重新温习如何回答。

### React 和 Vue 的区别是什么
1. **学习成本**上 Vue 更低，心智模型较为直观，而 React 需要更高的理解能力，比如说对于 Hook 的理解和限制，就像 useState 上这个东西为什么对于复杂类型需要创建新的再赋值。
2. **组件化方案**上 Vue SFC 既单文件组件，并且将模板和逻辑都放在一起；React 则使用 JSX 作为模板语法，All in JS。
3. **数据流**上 Vue 通问劫持 getter 和 setter 的内部方法来监听数据的变动，并加上发布订阅的模型实现响应式，并且可以通过 v-model 实现双向绑定，但实际上是个语法糖而 React 是单向数据流，需要编写事件处理来绑定 state 。对于 Vue Proxy 实现响应式，框架的开发者需要做大量的工作处理（比如对于数组有可能读取 .length，可能会被迭代等等所有情况）确保用户使用 Vue 开发的时候几乎不需要关注响应式系统中数据如何流动，只关心业务即可。
4. **生命周期**上 React 只需要一个 useEffect 就可以满足几乎所有的需求，而 Vue 的生命周期更加语义化，同时还有 keep-alive 的两个生命周期，更多更灵活。
5. **性能**方面 Vue 和 React 都使用虚拟 DOM 方案，Vue 使用双端 diff （但又可能使用的是最长上升子数组算法），React 则使用 Fiber 架构，用于背后渲染的线程和主线程做更好的并发从而优化性能，这一定程度上利用了时间片的思想，而 Vue 团队之前也打算引入，但对于性能提升实在有限并且性能足够优秀，于是放弃。

### Webpack 和 Vite 的区别
Webpack 和 Vite 都是当下最流行的打包工具，虽有相似之处，但也有一些差异
1. **构建速度**上 Vite 比 Webpack 要快很多，特别是热更新模块上，因为 Vite 采用的是即时编译，依赖于 ESM ，毋需打包再更新，而 Webpack 需要打包一次再更新。
2. **配置**上 Webpack 有更多，更灵活，但也更繁琐，比较适合大型项目的开发，而 Vite 则相对简单，体积小，更适合工具开发快速迭代。
3. **生态**上 Webpack 历史更悠久，因此生态和兼容性上更成熟，Vite 是相对较新生的工具，在生态和兼容性上还有更大的发展空间。

### HTML 标签上 async 和 defer 的区别
作用都是为了能够提高页面的加载性能和速度，都是异步
加载文件，不会影响 HTML 的渲染。但有一些区别在于脚本的执行时机。

async：加载完毕之后立即执行，但不能保证顺序（多个 async，加载和执行的顺序都无法确定）。

defer：HTML 渲染完再执行。

## 与八股不相关的问题
以下问题都是跟八股不太相关的问题，都是比较考验个人话语能力的问题。

### 简单的自我介绍

面试官您好，我是目前就读于 xx 大学24届计算机科学与技术的 xxx ，目前正在学习与从事前端开发，并正在维护两个已经上线但处于公测阶段的两个项目，一个是传统桌游结合OJ的平台，一个是2DCanvas小游戏。我的技术栈熟悉使用 Vue3 以及 React，也基本掌握 Svelte / SolidJS 前端框架的开发，并了解 SSR 框架 Next.js。后端接触过开发框架有 Java 的 SpringBoot，Python 的 Django，JS 的 Express 以及 NestJS 。能够使用 git 命令进行团队协作开发，以及前端工程化的工具 Webpack / Vite 的基本使用。

我的个人介绍完毕，感谢。

### 如何学习前端的，什么机缘巧合下开始做前端的
我个人原本进入大学攻读 CS 专业是为了能够做游戏设计游戏，而游戏设计本身也是一个比较复杂的与用户的交互设计，在校选修前端的时候认识到 canvas 标签，加上小学的时候学过 LOGO乌龟的编程绘图经验，于是便开始使用 canvas 2d 做游戏，并在此过程中接触到多多少少 JS 语法的问题（当初是使用 ES5 的语法比较多），为了解决问题我又很多时候也会上搜索引擎查询，以及查阅 mdn 文档去查阅 canvas 的一些 api，这算是对前端的一个入门吧。

然后在大二上数据结构实验课的时候我们是被要求在 北京大学botzone 这个平台上完成数据结构课设的，就是分组然后要求合作编写博弈程序，最后一对一进行比赛获取积分，通过积分排行榜来决定成绩。我当时更多关注在这个平台上的设计，加之之前做 canvas 游戏的一个开发经验，为了能够建立网页接触到并学习了 Vue3.2 的框架建立网页，然后又学习了 SpringBoot 的后端框架开发，接着还使用了 Docker 用来实现运行代码的沙箱环境。当时那个时间段就比较专注于这个业务上的开发吧，我每个周期开发完一整个网站之后一段时间就会想着重构，因此重构了有差不多三次了，每次重构都有前端后端整个系统的设计，当时的工作总的来说跟前端的关系不太大。后来也是机缘巧合下加入了前端开发的圈子的同好聊天群，在这上面的交流下认识到自己对前端的知识还是挺贫瘠的，因此之后就一边完善自己的这个项目，一边学习前端，要么就是看红宝书巩固一下基础，要么就是上掘金之类的网站或者在群友的交流中认识到还没见过的技术然后去查阅相关的资料，在这之下也认识到了其他前端工具比如 Webpack、React、Svelte、SolidJS，就最近前段时间我还一直在看 VueJS设计与实现这本书，深入了解响应式系统的实现。对于是否关注新技术而言，我其实是有关注，但是如果现阶段用不上的我一般很快就不会在意，我更专注的是基础技术能力的沉淀。

### 项目的亮点和难点

我觉得难点在于整个系统的设计，但其解决方案的设计上也是亮点所在。

首先这是一个要将传统的桌游与 OJ 结合的项目，先不说如何与 OJ 结合，光是游戏本身是一个比较复杂的交互设计已经足够难，它不只是要进行局面的变动，还要对局面进行判断（是否跳过、是否结束），是一个考验业务设计基本功的工作。

在这基础上我还要为了能够少写代码、以及无需关心实现细节（好比如游戏只有创建、初始化、输入指令改变局面、结束游戏等等这些都会有的方法），让不同的游戏都能够共用同一套逻辑，比如对于前端而言只需要渲染游戏的页面以及能够初始化以及能够输入指令、对于后端而言只需要能够初始化以及输入指令以及判断游戏局面，因此还需要进行抽象化，也是一个考验逻辑设计的工作。

接着是这个项目核心功能中，也要能够在网络上同步，跟其他人能够进行在线对战，前后端就必须做信息交流，通过 websocket 做信息交流本身不是一件难事，难点在于数据流的设计，有时候会不清楚数据是如何流动以及处理的，在 debug 上也有不小的工作量，这方面上就需要设计好像 Controller 一样的一个控制好数据流的流动的东西。

接着是代码运行系统，这个就是与 OJ 的结合的点。需要能够让用户编写代码，并通过游戏在每轮局面下发送局面信息，让代码运行系统能够获取局面信息并运行程序获取结果返回给运行游戏的后端，这在数据流上又有比较麻烦的设计考量了。

然后是需要根据不同的模式（是否使用代码来对战）来决定怎么给游戏发送指令，还是数据流上的问题，如果不使用代码运行就给 canvas 绑定点击事件等等，如果使用机器人就无法操作，未来还有可能有新的控制方式，对此我就定义了一个基类叫做 GameController 来将游戏的逻辑层和控制层分离，逻辑层无需关心如何被输入指令，控制层来决定好如何输入指令（用户手动操作？通过后端运行代码？）。这个也是相对比较简单的一个亮点。

然后是如何建立游戏的问题，前面说过我为了能够让不同游戏能够共用一套逻辑，就定义一个抽象游戏类，让所有游戏都要继承自这个游戏类并实现里面的抽象方法，虽然做到了屏蔽细节，但是如果要做到根据游戏名来实力化哪个游戏还是需要在同一个方法里面使用 switch case 来打表，一定程度上不够美观。我最近也使用 NestJS 去重构后端，我在此过程中尝试实现了装饰器，用来给实现的游戏类标注什么 tag 来实例化，这就不需要写 switch case 了，原理就是 IoC 控制反转和 DI 依赖注入，通过这个装饰器将这个实现游戏类注入到了统一的容器，直接根据 tag 来获取，就非常方便了，也使代码变得更美观了。

总之，难点都在于程序设计上。
